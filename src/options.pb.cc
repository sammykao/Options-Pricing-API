// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: options.proto

#include "options.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace options {

inline constexpr VarianceGammaOptionPricingResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : option_price_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR VarianceGammaOptionPricingResponse::VarianceGammaOptionPricingResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct VarianceGammaOptionPricingResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VarianceGammaOptionPricingResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VarianceGammaOptionPricingResponseDefaultTypeInternal() {}
  union {
    VarianceGammaOptionPricingResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VarianceGammaOptionPricingResponseDefaultTypeInternal _VarianceGammaOptionPricingResponse_default_instance_;

inline constexpr VarianceGammaOptionPricingRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : underlying_price_{0},
        strike_price_{0},
        time_to_expiration_{0},
        risk_free_interest_rate_{0},
        drift_rate_{0},
        volatility_{0},
        mean_reversion_parameter_{0},
        jump_intensity_{0},
        jump_size_distribution_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR VarianceGammaOptionPricingRequest::VarianceGammaOptionPricingRequest(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct VarianceGammaOptionPricingRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VarianceGammaOptionPricingRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VarianceGammaOptionPricingRequestDefaultTypeInternal() {}
  union {
    VarianceGammaOptionPricingRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VarianceGammaOptionPricingRequestDefaultTypeInternal _VarianceGammaOptionPricingRequest_default_instance_;

inline constexpr ScholesOptionPricingResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : option_price_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ScholesOptionPricingResponse::ScholesOptionPricingResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct ScholesOptionPricingResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScholesOptionPricingResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScholesOptionPricingResponseDefaultTypeInternal() {}
  union {
    ScholesOptionPricingResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScholesOptionPricingResponseDefaultTypeInternal _ScholesOptionPricingResponse_default_instance_;

inline constexpr ScholesOptionPricingRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : underlying_price_{0},
        strike_price_{0},
        time_to_expiration_{0},
        risk_free_interest_rate_{0},
        volatility_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ScholesOptionPricingRequest::ScholesOptionPricingRequest(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct ScholesOptionPricingRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScholesOptionPricingRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScholesOptionPricingRequestDefaultTypeInternal() {}
  union {
    ScholesOptionPricingRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScholesOptionPricingRequestDefaultTypeInternal _ScholesOptionPricingRequest_default_instance_;

inline constexpr HestonOptionPricingResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : option_price_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HestonOptionPricingResponse::HestonOptionPricingResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct HestonOptionPricingResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HestonOptionPricingResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HestonOptionPricingResponseDefaultTypeInternal() {}
  union {
    HestonOptionPricingResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HestonOptionPricingResponseDefaultTypeInternal _HestonOptionPricingResponse_default_instance_;

inline constexpr HestonOptionPricingRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : underlying_price_{0},
        strike_price_{0},
        time_to_expiration_{0},
        risk_free_interest_rate_{0},
        initial_volatility_{0},
        mean_reversion_rate_{0},
        volatility_of_volatility_{0},
        correlation_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HestonOptionPricingRequest::HestonOptionPricingRequest(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct HestonOptionPricingRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HestonOptionPricingRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HestonOptionPricingRequestDefaultTypeInternal() {}
  union {
    HestonOptionPricingRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HestonOptionPricingRequestDefaultTypeInternal _HestonOptionPricingRequest_default_instance_;
}  // namespace options
static ::_pb::Metadata file_level_metadata_options_2eproto[6];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_options_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_options_2eproto = nullptr;
const ::uint32_t TableStruct_options_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::options::ScholesOptionPricingRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::options::ScholesOptionPricingRequest, _impl_.underlying_price_),
    PROTOBUF_FIELD_OFFSET(::options::ScholesOptionPricingRequest, _impl_.strike_price_),
    PROTOBUF_FIELD_OFFSET(::options::ScholesOptionPricingRequest, _impl_.time_to_expiration_),
    PROTOBUF_FIELD_OFFSET(::options::ScholesOptionPricingRequest, _impl_.risk_free_interest_rate_),
    PROTOBUF_FIELD_OFFSET(::options::ScholesOptionPricingRequest, _impl_.volatility_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::options::ScholesOptionPricingResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::options::ScholesOptionPricingResponse, _impl_.option_price_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingRequest, _impl_.underlying_price_),
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingRequest, _impl_.strike_price_),
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingRequest, _impl_.time_to_expiration_),
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingRequest, _impl_.risk_free_interest_rate_),
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingRequest, _impl_.initial_volatility_),
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingRequest, _impl_.mean_reversion_rate_),
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingRequest, _impl_.volatility_of_volatility_),
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingRequest, _impl_.correlation_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::options::HestonOptionPricingResponse, _impl_.option_price_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingRequest, _impl_.underlying_price_),
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingRequest, _impl_.strike_price_),
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingRequest, _impl_.time_to_expiration_),
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingRequest, _impl_.risk_free_interest_rate_),
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingRequest, _impl_.drift_rate_),
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingRequest, _impl_.volatility_),
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingRequest, _impl_.mean_reversion_parameter_),
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingRequest, _impl_.jump_intensity_),
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingRequest, _impl_.jump_size_distribution_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::options::VarianceGammaOptionPricingResponse, _impl_.option_price_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, -1, -1, sizeof(::options::ScholesOptionPricingRequest)},
        {13, -1, -1, sizeof(::options::ScholesOptionPricingResponse)},
        {22, -1, -1, sizeof(::options::HestonOptionPricingRequest)},
        {38, -1, -1, sizeof(::options::HestonOptionPricingResponse)},
        {47, -1, -1, sizeof(::options::VarianceGammaOptionPricingRequest)},
        {64, -1, -1, sizeof(::options::VarianceGammaOptionPricingResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::options::_ScholesOptionPricingRequest_default_instance_._instance,
    &::options::_ScholesOptionPricingResponse_default_instance_._instance,
    &::options::_HestonOptionPricingRequest_default_instance_._instance,
    &::options::_HestonOptionPricingResponse_default_instance_._instance,
    &::options::_VarianceGammaOptionPricingRequest_default_instance_._instance,
    &::options::_VarianceGammaOptionPricingResponse_default_instance_._instance,
};
const char descriptor_table_protodef_options_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\roptions.proto\022\007options\"\236\001\n\033ScholesOpti"
    "onPricingRequest\022\030\n\020underlying_price\030\001 \001"
    "(\001\022\024\n\014strike_price\030\002 \001(\001\022\032\n\022time_to_expi"
    "ration\030\003 \001(\001\022\037\n\027risk_free_interest_rate\030"
    "\004 \001(\001\022\022\n\nvolatility\030\005 \001(\001\"4\n\034ScholesOpti"
    "onPricingResponse\022\024\n\014option_price\030\001 \001(\001\""
    "\371\001\n\032HestonOptionPricingRequest\022\030\n\020underl"
    "ying_price\030\001 \001(\001\022\024\n\014strike_price\030\002 \001(\001\022\032"
    "\n\022time_to_expiration\030\003 \001(\001\022\037\n\027risk_free_"
    "interest_rate\030\004 \001(\001\022\032\n\022initial_volatilit"
    "y\030\005 \001(\001\022\033\n\023mean_reversion_rate\030\006 \001(\001\022 \n\030"
    "volatility_of_volatility\030\007 \001(\001\022\023\n\013correl"
    "ation\030\010 \001(\001\"3\n\033HestonOptionPricingRespon"
    "se\022\024\n\014option_price\030\001 \001(\001\"\222\002\n!VarianceGam"
    "maOptionPricingRequest\022\030\n\020underlying_pri"
    "ce\030\001 \001(\001\022\024\n\014strike_price\030\002 \001(\001\022\032\n\022time_t"
    "o_expiration\030\003 \001(\001\022\037\n\027risk_free_interest"
    "_rate\030\004 \001(\001\022\022\n\ndrift_rate\030\005 \001(\001\022\022\n\nvolat"
    "ility\030\006 \001(\001\022 \n\030mean_reversion_parameter\030"
    "\007 \001(\001\022\026\n\016jump_intensity\030\010 \001(\001\022\036\n\026jump_si"
    "ze_distribution\030\t \001(\001\":\n\"VarianceGammaOp"
    "tionPricingResponse\022\024\n\014option_price\030\001 \001("
    "\0012\316\002\n\016OptionsService\022c\n\022PriceOptionSchol"
    "es\022$.options.ScholesOptionPricingRequest"
    "\032%.options.ScholesOptionPricingResponse\""
    "\000\022`\n\021PriceOptionHeston\022#.options.HestonO"
    "ptionPricingRequest\032$.options.HestonOpti"
    "onPricingResponse\"\000\022u\n\030PriceOptionVarian"
    "ceGamma\022*.options.VarianceGammaOptionPri"
    "cingRequest\032+.options.VarianceGammaOptio"
    "nPricingResponse\"\000b\006proto3"
};
static ::absl::once_flag descriptor_table_options_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_options_2eproto = {
    false,
    false,
    1226,
    descriptor_table_protodef_options_2eproto,
    "options.proto",
    &descriptor_table_options_2eproto_once,
    nullptr,
    0,
    6,
    schemas,
    file_default_instances,
    TableStruct_options_2eproto::offsets,
    file_level_metadata_options_2eproto,
    file_level_enum_descriptors_options_2eproto,
    file_level_service_descriptors_options_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_options_2eproto_getter() {
  return &descriptor_table_options_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_options_2eproto(&descriptor_table_options_2eproto);
namespace options {
// ===================================================================

class ScholesOptionPricingRequest::_Internal {
 public:
};

ScholesOptionPricingRequest::ScholesOptionPricingRequest(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:options.ScholesOptionPricingRequest)
}
ScholesOptionPricingRequest::ScholesOptionPricingRequest(
    ::google::protobuf::Arena* arena, const ScholesOptionPricingRequest& from)
    : ScholesOptionPricingRequest(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE ScholesOptionPricingRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void ScholesOptionPricingRequest::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, underlying_price_),
           0,
           offsetof(Impl_, volatility_) -
               offsetof(Impl_, underlying_price_) +
               sizeof(Impl_::volatility_));
}
ScholesOptionPricingRequest::~ScholesOptionPricingRequest() {
  // @@protoc_insertion_point(destructor:options.ScholesOptionPricingRequest)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ScholesOptionPricingRequest::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void ScholesOptionPricingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:options.ScholesOptionPricingRequest)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.underlying_price_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.volatility_) -
      reinterpret_cast<char*>(&_impl_.underlying_price_)) + sizeof(_impl_.volatility_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ScholesOptionPricingRequest::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> ScholesOptionPricingRequest::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_ScholesOptionPricingRequest_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double underlying_price = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.underlying_price_)}},
    // double strike_price = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.strike_price_)}},
    // double time_to_expiration = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.time_to_expiration_)}},
    // double risk_free_interest_rate = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.risk_free_interest_rate_)}},
    // double volatility = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.volatility_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double underlying_price = 1;
    {PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.underlying_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double strike_price = 2;
    {PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.strike_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double time_to_expiration = 3;
    {PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.time_to_expiration_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double risk_free_interest_rate = 4;
    {PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.risk_free_interest_rate_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double volatility = 5;
    {PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.volatility_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* ScholesOptionPricingRequest::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:options.ScholesOptionPricingRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double underlying_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_underlying_price = this->_internal_underlying_price();
  ::uint64_t raw_underlying_price;
  memcpy(&raw_underlying_price, &tmp_underlying_price, sizeof(tmp_underlying_price));
  if (raw_underlying_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_underlying_price(), target);
  }

  // double strike_price = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_strike_price = this->_internal_strike_price();
  ::uint64_t raw_strike_price;
  memcpy(&raw_strike_price, &tmp_strike_price, sizeof(tmp_strike_price));
  if (raw_strike_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_strike_price(), target);
  }

  // double time_to_expiration = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_time_to_expiration = this->_internal_time_to_expiration();
  ::uint64_t raw_time_to_expiration;
  memcpy(&raw_time_to_expiration, &tmp_time_to_expiration, sizeof(tmp_time_to_expiration));
  if (raw_time_to_expiration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_time_to_expiration(), target);
  }

  // double risk_free_interest_rate = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_risk_free_interest_rate = this->_internal_risk_free_interest_rate();
  ::uint64_t raw_risk_free_interest_rate;
  memcpy(&raw_risk_free_interest_rate, &tmp_risk_free_interest_rate, sizeof(tmp_risk_free_interest_rate));
  if (raw_risk_free_interest_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_risk_free_interest_rate(), target);
  }

  // double volatility = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volatility = this->_internal_volatility();
  ::uint64_t raw_volatility;
  memcpy(&raw_volatility, &tmp_volatility, sizeof(tmp_volatility));
  if (raw_volatility != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_volatility(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:options.ScholesOptionPricingRequest)
  return target;
}

::size_t ScholesOptionPricingRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:options.ScholesOptionPricingRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double underlying_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_underlying_price = this->_internal_underlying_price();
  ::uint64_t raw_underlying_price;
  memcpy(&raw_underlying_price, &tmp_underlying_price, sizeof(tmp_underlying_price));
  if (raw_underlying_price != 0) {
    total_size += 9;
  }

  // double strike_price = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_strike_price = this->_internal_strike_price();
  ::uint64_t raw_strike_price;
  memcpy(&raw_strike_price, &tmp_strike_price, sizeof(tmp_strike_price));
  if (raw_strike_price != 0) {
    total_size += 9;
  }

  // double time_to_expiration = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_time_to_expiration = this->_internal_time_to_expiration();
  ::uint64_t raw_time_to_expiration;
  memcpy(&raw_time_to_expiration, &tmp_time_to_expiration, sizeof(tmp_time_to_expiration));
  if (raw_time_to_expiration != 0) {
    total_size += 9;
  }

  // double risk_free_interest_rate = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_risk_free_interest_rate = this->_internal_risk_free_interest_rate();
  ::uint64_t raw_risk_free_interest_rate;
  memcpy(&raw_risk_free_interest_rate, &tmp_risk_free_interest_rate, sizeof(tmp_risk_free_interest_rate));
  if (raw_risk_free_interest_rate != 0) {
    total_size += 9;
  }

  // double volatility = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volatility = this->_internal_volatility();
  ::uint64_t raw_volatility;
  memcpy(&raw_volatility, &tmp_volatility, sizeof(tmp_volatility));
  if (raw_volatility != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ScholesOptionPricingRequest::_class_data_ = {
    ScholesOptionPricingRequest::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* ScholesOptionPricingRequest::GetClassData() const {
  return &_class_data_;
}

void ScholesOptionPricingRequest::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ScholesOptionPricingRequest*>(&to_msg);
  auto& from = static_cast<const ScholesOptionPricingRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:options.ScholesOptionPricingRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_underlying_price = from._internal_underlying_price();
  ::uint64_t raw_underlying_price;
  memcpy(&raw_underlying_price, &tmp_underlying_price, sizeof(tmp_underlying_price));
  if (raw_underlying_price != 0) {
    _this->_internal_set_underlying_price(from._internal_underlying_price());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_strike_price = from._internal_strike_price();
  ::uint64_t raw_strike_price;
  memcpy(&raw_strike_price, &tmp_strike_price, sizeof(tmp_strike_price));
  if (raw_strike_price != 0) {
    _this->_internal_set_strike_price(from._internal_strike_price());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_time_to_expiration = from._internal_time_to_expiration();
  ::uint64_t raw_time_to_expiration;
  memcpy(&raw_time_to_expiration, &tmp_time_to_expiration, sizeof(tmp_time_to_expiration));
  if (raw_time_to_expiration != 0) {
    _this->_internal_set_time_to_expiration(from._internal_time_to_expiration());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_risk_free_interest_rate = from._internal_risk_free_interest_rate();
  ::uint64_t raw_risk_free_interest_rate;
  memcpy(&raw_risk_free_interest_rate, &tmp_risk_free_interest_rate, sizeof(tmp_risk_free_interest_rate));
  if (raw_risk_free_interest_rate != 0) {
    _this->_internal_set_risk_free_interest_rate(from._internal_risk_free_interest_rate());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volatility = from._internal_volatility();
  ::uint64_t raw_volatility;
  memcpy(&raw_volatility, &tmp_volatility, sizeof(tmp_volatility));
  if (raw_volatility != 0) {
    _this->_internal_set_volatility(from._internal_volatility());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ScholesOptionPricingRequest::CopyFrom(const ScholesOptionPricingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:options.ScholesOptionPricingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ScholesOptionPricingRequest::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* ScholesOptionPricingRequest::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void ScholesOptionPricingRequest::InternalSwap(ScholesOptionPricingRequest* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.volatility_)
      + sizeof(ScholesOptionPricingRequest::_impl_.volatility_)
      - PROTOBUF_FIELD_OFFSET(ScholesOptionPricingRequest, _impl_.underlying_price_)>(
          reinterpret_cast<char*>(&_impl_.underlying_price_),
          reinterpret_cast<char*>(&other->_impl_.underlying_price_));
}

::google::protobuf::Metadata ScholesOptionPricingRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_options_2eproto_getter, &descriptor_table_options_2eproto_once,
      file_level_metadata_options_2eproto[0]);
}
// ===================================================================

class ScholesOptionPricingResponse::_Internal {
 public:
};

ScholesOptionPricingResponse::ScholesOptionPricingResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:options.ScholesOptionPricingResponse)
}
ScholesOptionPricingResponse::ScholesOptionPricingResponse(
    ::google::protobuf::Arena* arena, const ScholesOptionPricingResponse& from)
    : ScholesOptionPricingResponse(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE ScholesOptionPricingResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void ScholesOptionPricingResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.option_price_ = {};
}
ScholesOptionPricingResponse::~ScholesOptionPricingResponse() {
  // @@protoc_insertion_point(destructor:options.ScholesOptionPricingResponse)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ScholesOptionPricingResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void ScholesOptionPricingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:options.ScholesOptionPricingResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.option_price_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ScholesOptionPricingResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> ScholesOptionPricingResponse::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_ScholesOptionPricingResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double option_price = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(ScholesOptionPricingResponse, _impl_.option_price_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double option_price = 1;
    {PROTOBUF_FIELD_OFFSET(ScholesOptionPricingResponse, _impl_.option_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* ScholesOptionPricingResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:options.ScholesOptionPricingResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double option_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_option_price = this->_internal_option_price();
  ::uint64_t raw_option_price;
  memcpy(&raw_option_price, &tmp_option_price, sizeof(tmp_option_price));
  if (raw_option_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_option_price(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:options.ScholesOptionPricingResponse)
  return target;
}

::size_t ScholesOptionPricingResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:options.ScholesOptionPricingResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double option_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_option_price = this->_internal_option_price();
  ::uint64_t raw_option_price;
  memcpy(&raw_option_price, &tmp_option_price, sizeof(tmp_option_price));
  if (raw_option_price != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ScholesOptionPricingResponse::_class_data_ = {
    ScholesOptionPricingResponse::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* ScholesOptionPricingResponse::GetClassData() const {
  return &_class_data_;
}

void ScholesOptionPricingResponse::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ScholesOptionPricingResponse*>(&to_msg);
  auto& from = static_cast<const ScholesOptionPricingResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:options.ScholesOptionPricingResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_option_price = from._internal_option_price();
  ::uint64_t raw_option_price;
  memcpy(&raw_option_price, &tmp_option_price, sizeof(tmp_option_price));
  if (raw_option_price != 0) {
    _this->_internal_set_option_price(from._internal_option_price());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ScholesOptionPricingResponse::CopyFrom(const ScholesOptionPricingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:options.ScholesOptionPricingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ScholesOptionPricingResponse::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* ScholesOptionPricingResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void ScholesOptionPricingResponse::InternalSwap(ScholesOptionPricingResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.option_price_, other->_impl_.option_price_);
}

::google::protobuf::Metadata ScholesOptionPricingResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_options_2eproto_getter, &descriptor_table_options_2eproto_once,
      file_level_metadata_options_2eproto[1]);
}
// ===================================================================

class HestonOptionPricingRequest::_Internal {
 public:
};

HestonOptionPricingRequest::HestonOptionPricingRequest(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:options.HestonOptionPricingRequest)
}
HestonOptionPricingRequest::HestonOptionPricingRequest(
    ::google::protobuf::Arena* arena, const HestonOptionPricingRequest& from)
    : HestonOptionPricingRequest(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE HestonOptionPricingRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void HestonOptionPricingRequest::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, underlying_price_),
           0,
           offsetof(Impl_, correlation_) -
               offsetof(Impl_, underlying_price_) +
               sizeof(Impl_::correlation_));
}
HestonOptionPricingRequest::~HestonOptionPricingRequest() {
  // @@protoc_insertion_point(destructor:options.HestonOptionPricingRequest)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void HestonOptionPricingRequest::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void HestonOptionPricingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:options.HestonOptionPricingRequest)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.underlying_price_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.correlation_) -
      reinterpret_cast<char*>(&_impl_.underlying_price_)) + sizeof(_impl_.correlation_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* HestonOptionPricingRequest::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2> HestonOptionPricingRequest::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_HestonOptionPricingRequest_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double correlation = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 63, 0, PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.correlation_)}},
    // double underlying_price = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.underlying_price_)}},
    // double strike_price = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.strike_price_)}},
    // double time_to_expiration = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.time_to_expiration_)}},
    // double risk_free_interest_rate = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.risk_free_interest_rate_)}},
    // double initial_volatility = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.initial_volatility_)}},
    // double mean_reversion_rate = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.mean_reversion_rate_)}},
    // double volatility_of_volatility = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.volatility_of_volatility_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double underlying_price = 1;
    {PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.underlying_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double strike_price = 2;
    {PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.strike_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double time_to_expiration = 3;
    {PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.time_to_expiration_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double risk_free_interest_rate = 4;
    {PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.risk_free_interest_rate_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double initial_volatility = 5;
    {PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.initial_volatility_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double mean_reversion_rate = 6;
    {PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.mean_reversion_rate_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double volatility_of_volatility = 7;
    {PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.volatility_of_volatility_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double correlation = 8;
    {PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.correlation_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* HestonOptionPricingRequest::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:options.HestonOptionPricingRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double underlying_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_underlying_price = this->_internal_underlying_price();
  ::uint64_t raw_underlying_price;
  memcpy(&raw_underlying_price, &tmp_underlying_price, sizeof(tmp_underlying_price));
  if (raw_underlying_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_underlying_price(), target);
  }

  // double strike_price = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_strike_price = this->_internal_strike_price();
  ::uint64_t raw_strike_price;
  memcpy(&raw_strike_price, &tmp_strike_price, sizeof(tmp_strike_price));
  if (raw_strike_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_strike_price(), target);
  }

  // double time_to_expiration = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_time_to_expiration = this->_internal_time_to_expiration();
  ::uint64_t raw_time_to_expiration;
  memcpy(&raw_time_to_expiration, &tmp_time_to_expiration, sizeof(tmp_time_to_expiration));
  if (raw_time_to_expiration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_time_to_expiration(), target);
  }

  // double risk_free_interest_rate = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_risk_free_interest_rate = this->_internal_risk_free_interest_rate();
  ::uint64_t raw_risk_free_interest_rate;
  memcpy(&raw_risk_free_interest_rate, &tmp_risk_free_interest_rate, sizeof(tmp_risk_free_interest_rate));
  if (raw_risk_free_interest_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_risk_free_interest_rate(), target);
  }

  // double initial_volatility = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_initial_volatility = this->_internal_initial_volatility();
  ::uint64_t raw_initial_volatility;
  memcpy(&raw_initial_volatility, &tmp_initial_volatility, sizeof(tmp_initial_volatility));
  if (raw_initial_volatility != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_initial_volatility(), target);
  }

  // double mean_reversion_rate = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mean_reversion_rate = this->_internal_mean_reversion_rate();
  ::uint64_t raw_mean_reversion_rate;
  memcpy(&raw_mean_reversion_rate, &tmp_mean_reversion_rate, sizeof(tmp_mean_reversion_rate));
  if (raw_mean_reversion_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_mean_reversion_rate(), target);
  }

  // double volatility_of_volatility = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volatility_of_volatility = this->_internal_volatility_of_volatility();
  ::uint64_t raw_volatility_of_volatility;
  memcpy(&raw_volatility_of_volatility, &tmp_volatility_of_volatility, sizeof(tmp_volatility_of_volatility));
  if (raw_volatility_of_volatility != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_volatility_of_volatility(), target);
  }

  // double correlation = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_correlation = this->_internal_correlation();
  ::uint64_t raw_correlation;
  memcpy(&raw_correlation, &tmp_correlation, sizeof(tmp_correlation));
  if (raw_correlation != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_correlation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:options.HestonOptionPricingRequest)
  return target;
}

::size_t HestonOptionPricingRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:options.HestonOptionPricingRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double underlying_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_underlying_price = this->_internal_underlying_price();
  ::uint64_t raw_underlying_price;
  memcpy(&raw_underlying_price, &tmp_underlying_price, sizeof(tmp_underlying_price));
  if (raw_underlying_price != 0) {
    total_size += 9;
  }

  // double strike_price = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_strike_price = this->_internal_strike_price();
  ::uint64_t raw_strike_price;
  memcpy(&raw_strike_price, &tmp_strike_price, sizeof(tmp_strike_price));
  if (raw_strike_price != 0) {
    total_size += 9;
  }

  // double time_to_expiration = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_time_to_expiration = this->_internal_time_to_expiration();
  ::uint64_t raw_time_to_expiration;
  memcpy(&raw_time_to_expiration, &tmp_time_to_expiration, sizeof(tmp_time_to_expiration));
  if (raw_time_to_expiration != 0) {
    total_size += 9;
  }

  // double risk_free_interest_rate = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_risk_free_interest_rate = this->_internal_risk_free_interest_rate();
  ::uint64_t raw_risk_free_interest_rate;
  memcpy(&raw_risk_free_interest_rate, &tmp_risk_free_interest_rate, sizeof(tmp_risk_free_interest_rate));
  if (raw_risk_free_interest_rate != 0) {
    total_size += 9;
  }

  // double initial_volatility = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_initial_volatility = this->_internal_initial_volatility();
  ::uint64_t raw_initial_volatility;
  memcpy(&raw_initial_volatility, &tmp_initial_volatility, sizeof(tmp_initial_volatility));
  if (raw_initial_volatility != 0) {
    total_size += 9;
  }

  // double mean_reversion_rate = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mean_reversion_rate = this->_internal_mean_reversion_rate();
  ::uint64_t raw_mean_reversion_rate;
  memcpy(&raw_mean_reversion_rate, &tmp_mean_reversion_rate, sizeof(tmp_mean_reversion_rate));
  if (raw_mean_reversion_rate != 0) {
    total_size += 9;
  }

  // double volatility_of_volatility = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volatility_of_volatility = this->_internal_volatility_of_volatility();
  ::uint64_t raw_volatility_of_volatility;
  memcpy(&raw_volatility_of_volatility, &tmp_volatility_of_volatility, sizeof(tmp_volatility_of_volatility));
  if (raw_volatility_of_volatility != 0) {
    total_size += 9;
  }

  // double correlation = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_correlation = this->_internal_correlation();
  ::uint64_t raw_correlation;
  memcpy(&raw_correlation, &tmp_correlation, sizeof(tmp_correlation));
  if (raw_correlation != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData HestonOptionPricingRequest::_class_data_ = {
    HestonOptionPricingRequest::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* HestonOptionPricingRequest::GetClassData() const {
  return &_class_data_;
}

void HestonOptionPricingRequest::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<HestonOptionPricingRequest*>(&to_msg);
  auto& from = static_cast<const HestonOptionPricingRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:options.HestonOptionPricingRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_underlying_price = from._internal_underlying_price();
  ::uint64_t raw_underlying_price;
  memcpy(&raw_underlying_price, &tmp_underlying_price, sizeof(tmp_underlying_price));
  if (raw_underlying_price != 0) {
    _this->_internal_set_underlying_price(from._internal_underlying_price());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_strike_price = from._internal_strike_price();
  ::uint64_t raw_strike_price;
  memcpy(&raw_strike_price, &tmp_strike_price, sizeof(tmp_strike_price));
  if (raw_strike_price != 0) {
    _this->_internal_set_strike_price(from._internal_strike_price());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_time_to_expiration = from._internal_time_to_expiration();
  ::uint64_t raw_time_to_expiration;
  memcpy(&raw_time_to_expiration, &tmp_time_to_expiration, sizeof(tmp_time_to_expiration));
  if (raw_time_to_expiration != 0) {
    _this->_internal_set_time_to_expiration(from._internal_time_to_expiration());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_risk_free_interest_rate = from._internal_risk_free_interest_rate();
  ::uint64_t raw_risk_free_interest_rate;
  memcpy(&raw_risk_free_interest_rate, &tmp_risk_free_interest_rate, sizeof(tmp_risk_free_interest_rate));
  if (raw_risk_free_interest_rate != 0) {
    _this->_internal_set_risk_free_interest_rate(from._internal_risk_free_interest_rate());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_initial_volatility = from._internal_initial_volatility();
  ::uint64_t raw_initial_volatility;
  memcpy(&raw_initial_volatility, &tmp_initial_volatility, sizeof(tmp_initial_volatility));
  if (raw_initial_volatility != 0) {
    _this->_internal_set_initial_volatility(from._internal_initial_volatility());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mean_reversion_rate = from._internal_mean_reversion_rate();
  ::uint64_t raw_mean_reversion_rate;
  memcpy(&raw_mean_reversion_rate, &tmp_mean_reversion_rate, sizeof(tmp_mean_reversion_rate));
  if (raw_mean_reversion_rate != 0) {
    _this->_internal_set_mean_reversion_rate(from._internal_mean_reversion_rate());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volatility_of_volatility = from._internal_volatility_of_volatility();
  ::uint64_t raw_volatility_of_volatility;
  memcpy(&raw_volatility_of_volatility, &tmp_volatility_of_volatility, sizeof(tmp_volatility_of_volatility));
  if (raw_volatility_of_volatility != 0) {
    _this->_internal_set_volatility_of_volatility(from._internal_volatility_of_volatility());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_correlation = from._internal_correlation();
  ::uint64_t raw_correlation;
  memcpy(&raw_correlation, &tmp_correlation, sizeof(tmp_correlation));
  if (raw_correlation != 0) {
    _this->_internal_set_correlation(from._internal_correlation());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HestonOptionPricingRequest::CopyFrom(const HestonOptionPricingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:options.HestonOptionPricingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool HestonOptionPricingRequest::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* HestonOptionPricingRequest::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void HestonOptionPricingRequest::InternalSwap(HestonOptionPricingRequest* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.correlation_)
      + sizeof(HestonOptionPricingRequest::_impl_.correlation_)
      - PROTOBUF_FIELD_OFFSET(HestonOptionPricingRequest, _impl_.underlying_price_)>(
          reinterpret_cast<char*>(&_impl_.underlying_price_),
          reinterpret_cast<char*>(&other->_impl_.underlying_price_));
}

::google::protobuf::Metadata HestonOptionPricingRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_options_2eproto_getter, &descriptor_table_options_2eproto_once,
      file_level_metadata_options_2eproto[2]);
}
// ===================================================================

class HestonOptionPricingResponse::_Internal {
 public:
};

HestonOptionPricingResponse::HestonOptionPricingResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:options.HestonOptionPricingResponse)
}
HestonOptionPricingResponse::HestonOptionPricingResponse(
    ::google::protobuf::Arena* arena, const HestonOptionPricingResponse& from)
    : HestonOptionPricingResponse(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE HestonOptionPricingResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void HestonOptionPricingResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.option_price_ = {};
}
HestonOptionPricingResponse::~HestonOptionPricingResponse() {
  // @@protoc_insertion_point(destructor:options.HestonOptionPricingResponse)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void HestonOptionPricingResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void HestonOptionPricingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:options.HestonOptionPricingResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.option_price_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* HestonOptionPricingResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> HestonOptionPricingResponse::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_HestonOptionPricingResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double option_price = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(HestonOptionPricingResponse, _impl_.option_price_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double option_price = 1;
    {PROTOBUF_FIELD_OFFSET(HestonOptionPricingResponse, _impl_.option_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* HestonOptionPricingResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:options.HestonOptionPricingResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double option_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_option_price = this->_internal_option_price();
  ::uint64_t raw_option_price;
  memcpy(&raw_option_price, &tmp_option_price, sizeof(tmp_option_price));
  if (raw_option_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_option_price(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:options.HestonOptionPricingResponse)
  return target;
}

::size_t HestonOptionPricingResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:options.HestonOptionPricingResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double option_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_option_price = this->_internal_option_price();
  ::uint64_t raw_option_price;
  memcpy(&raw_option_price, &tmp_option_price, sizeof(tmp_option_price));
  if (raw_option_price != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData HestonOptionPricingResponse::_class_data_ = {
    HestonOptionPricingResponse::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* HestonOptionPricingResponse::GetClassData() const {
  return &_class_data_;
}

void HestonOptionPricingResponse::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<HestonOptionPricingResponse*>(&to_msg);
  auto& from = static_cast<const HestonOptionPricingResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:options.HestonOptionPricingResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_option_price = from._internal_option_price();
  ::uint64_t raw_option_price;
  memcpy(&raw_option_price, &tmp_option_price, sizeof(tmp_option_price));
  if (raw_option_price != 0) {
    _this->_internal_set_option_price(from._internal_option_price());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HestonOptionPricingResponse::CopyFrom(const HestonOptionPricingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:options.HestonOptionPricingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool HestonOptionPricingResponse::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* HestonOptionPricingResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void HestonOptionPricingResponse::InternalSwap(HestonOptionPricingResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.option_price_, other->_impl_.option_price_);
}

::google::protobuf::Metadata HestonOptionPricingResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_options_2eproto_getter, &descriptor_table_options_2eproto_once,
      file_level_metadata_options_2eproto[3]);
}
// ===================================================================

class VarianceGammaOptionPricingRequest::_Internal {
 public:
};

VarianceGammaOptionPricingRequest::VarianceGammaOptionPricingRequest(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:options.VarianceGammaOptionPricingRequest)
}
VarianceGammaOptionPricingRequest::VarianceGammaOptionPricingRequest(
    ::google::protobuf::Arena* arena, const VarianceGammaOptionPricingRequest& from)
    : VarianceGammaOptionPricingRequest(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE VarianceGammaOptionPricingRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void VarianceGammaOptionPricingRequest::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, underlying_price_),
           0,
           offsetof(Impl_, jump_size_distribution_) -
               offsetof(Impl_, underlying_price_) +
               sizeof(Impl_::jump_size_distribution_));
}
VarianceGammaOptionPricingRequest::~VarianceGammaOptionPricingRequest() {
  // @@protoc_insertion_point(destructor:options.VarianceGammaOptionPricingRequest)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VarianceGammaOptionPricingRequest::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void VarianceGammaOptionPricingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:options.VarianceGammaOptionPricingRequest)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.underlying_price_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.jump_size_distribution_) -
      reinterpret_cast<char*>(&_impl_.underlying_price_)) + sizeof(_impl_.jump_size_distribution_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VarianceGammaOptionPricingRequest::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 0, 0, 2> VarianceGammaOptionPricingRequest::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VarianceGammaOptionPricingRequest_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double underlying_price = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.underlying_price_)}},
    // double strike_price = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.strike_price_)}},
    // double time_to_expiration = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.time_to_expiration_)}},
    // double risk_free_interest_rate = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.risk_free_interest_rate_)}},
    // double drift_rate = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.drift_rate_)}},
    // double volatility = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.volatility_)}},
    // double mean_reversion_parameter = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.mean_reversion_parameter_)}},
    // double jump_intensity = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 63, 0, PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.jump_intensity_)}},
    // double jump_size_distribution = 9;
    {::_pbi::TcParser::FastF64S1,
     {73, 63, 0, PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.jump_size_distribution_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double underlying_price = 1;
    {PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.underlying_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double strike_price = 2;
    {PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.strike_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double time_to_expiration = 3;
    {PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.time_to_expiration_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double risk_free_interest_rate = 4;
    {PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.risk_free_interest_rate_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double drift_rate = 5;
    {PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.drift_rate_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double volatility = 6;
    {PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.volatility_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double mean_reversion_parameter = 7;
    {PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.mean_reversion_parameter_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double jump_intensity = 8;
    {PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.jump_intensity_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double jump_size_distribution = 9;
    {PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.jump_size_distribution_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VarianceGammaOptionPricingRequest::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:options.VarianceGammaOptionPricingRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double underlying_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_underlying_price = this->_internal_underlying_price();
  ::uint64_t raw_underlying_price;
  memcpy(&raw_underlying_price, &tmp_underlying_price, sizeof(tmp_underlying_price));
  if (raw_underlying_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_underlying_price(), target);
  }

  // double strike_price = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_strike_price = this->_internal_strike_price();
  ::uint64_t raw_strike_price;
  memcpy(&raw_strike_price, &tmp_strike_price, sizeof(tmp_strike_price));
  if (raw_strike_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_strike_price(), target);
  }

  // double time_to_expiration = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_time_to_expiration = this->_internal_time_to_expiration();
  ::uint64_t raw_time_to_expiration;
  memcpy(&raw_time_to_expiration, &tmp_time_to_expiration, sizeof(tmp_time_to_expiration));
  if (raw_time_to_expiration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_time_to_expiration(), target);
  }

  // double risk_free_interest_rate = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_risk_free_interest_rate = this->_internal_risk_free_interest_rate();
  ::uint64_t raw_risk_free_interest_rate;
  memcpy(&raw_risk_free_interest_rate, &tmp_risk_free_interest_rate, sizeof(tmp_risk_free_interest_rate));
  if (raw_risk_free_interest_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_risk_free_interest_rate(), target);
  }

  // double drift_rate = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_drift_rate = this->_internal_drift_rate();
  ::uint64_t raw_drift_rate;
  memcpy(&raw_drift_rate, &tmp_drift_rate, sizeof(tmp_drift_rate));
  if (raw_drift_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_drift_rate(), target);
  }

  // double volatility = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volatility = this->_internal_volatility();
  ::uint64_t raw_volatility;
  memcpy(&raw_volatility, &tmp_volatility, sizeof(tmp_volatility));
  if (raw_volatility != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_volatility(), target);
  }

  // double mean_reversion_parameter = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mean_reversion_parameter = this->_internal_mean_reversion_parameter();
  ::uint64_t raw_mean_reversion_parameter;
  memcpy(&raw_mean_reversion_parameter, &tmp_mean_reversion_parameter, sizeof(tmp_mean_reversion_parameter));
  if (raw_mean_reversion_parameter != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_mean_reversion_parameter(), target);
  }

  // double jump_intensity = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jump_intensity = this->_internal_jump_intensity();
  ::uint64_t raw_jump_intensity;
  memcpy(&raw_jump_intensity, &tmp_jump_intensity, sizeof(tmp_jump_intensity));
  if (raw_jump_intensity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_jump_intensity(), target);
  }

  // double jump_size_distribution = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jump_size_distribution = this->_internal_jump_size_distribution();
  ::uint64_t raw_jump_size_distribution;
  memcpy(&raw_jump_size_distribution, &tmp_jump_size_distribution, sizeof(tmp_jump_size_distribution));
  if (raw_jump_size_distribution != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_jump_size_distribution(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:options.VarianceGammaOptionPricingRequest)
  return target;
}

::size_t VarianceGammaOptionPricingRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:options.VarianceGammaOptionPricingRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double underlying_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_underlying_price = this->_internal_underlying_price();
  ::uint64_t raw_underlying_price;
  memcpy(&raw_underlying_price, &tmp_underlying_price, sizeof(tmp_underlying_price));
  if (raw_underlying_price != 0) {
    total_size += 9;
  }

  // double strike_price = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_strike_price = this->_internal_strike_price();
  ::uint64_t raw_strike_price;
  memcpy(&raw_strike_price, &tmp_strike_price, sizeof(tmp_strike_price));
  if (raw_strike_price != 0) {
    total_size += 9;
  }

  // double time_to_expiration = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_time_to_expiration = this->_internal_time_to_expiration();
  ::uint64_t raw_time_to_expiration;
  memcpy(&raw_time_to_expiration, &tmp_time_to_expiration, sizeof(tmp_time_to_expiration));
  if (raw_time_to_expiration != 0) {
    total_size += 9;
  }

  // double risk_free_interest_rate = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_risk_free_interest_rate = this->_internal_risk_free_interest_rate();
  ::uint64_t raw_risk_free_interest_rate;
  memcpy(&raw_risk_free_interest_rate, &tmp_risk_free_interest_rate, sizeof(tmp_risk_free_interest_rate));
  if (raw_risk_free_interest_rate != 0) {
    total_size += 9;
  }

  // double drift_rate = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_drift_rate = this->_internal_drift_rate();
  ::uint64_t raw_drift_rate;
  memcpy(&raw_drift_rate, &tmp_drift_rate, sizeof(tmp_drift_rate));
  if (raw_drift_rate != 0) {
    total_size += 9;
  }

  // double volatility = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volatility = this->_internal_volatility();
  ::uint64_t raw_volatility;
  memcpy(&raw_volatility, &tmp_volatility, sizeof(tmp_volatility));
  if (raw_volatility != 0) {
    total_size += 9;
  }

  // double mean_reversion_parameter = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mean_reversion_parameter = this->_internal_mean_reversion_parameter();
  ::uint64_t raw_mean_reversion_parameter;
  memcpy(&raw_mean_reversion_parameter, &tmp_mean_reversion_parameter, sizeof(tmp_mean_reversion_parameter));
  if (raw_mean_reversion_parameter != 0) {
    total_size += 9;
  }

  // double jump_intensity = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jump_intensity = this->_internal_jump_intensity();
  ::uint64_t raw_jump_intensity;
  memcpy(&raw_jump_intensity, &tmp_jump_intensity, sizeof(tmp_jump_intensity));
  if (raw_jump_intensity != 0) {
    total_size += 9;
  }

  // double jump_size_distribution = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jump_size_distribution = this->_internal_jump_size_distribution();
  ::uint64_t raw_jump_size_distribution;
  memcpy(&raw_jump_size_distribution, &tmp_jump_size_distribution, sizeof(tmp_jump_size_distribution));
  if (raw_jump_size_distribution != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VarianceGammaOptionPricingRequest::_class_data_ = {
    VarianceGammaOptionPricingRequest::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* VarianceGammaOptionPricingRequest::GetClassData() const {
  return &_class_data_;
}

void VarianceGammaOptionPricingRequest::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VarianceGammaOptionPricingRequest*>(&to_msg);
  auto& from = static_cast<const VarianceGammaOptionPricingRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:options.VarianceGammaOptionPricingRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_underlying_price = from._internal_underlying_price();
  ::uint64_t raw_underlying_price;
  memcpy(&raw_underlying_price, &tmp_underlying_price, sizeof(tmp_underlying_price));
  if (raw_underlying_price != 0) {
    _this->_internal_set_underlying_price(from._internal_underlying_price());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_strike_price = from._internal_strike_price();
  ::uint64_t raw_strike_price;
  memcpy(&raw_strike_price, &tmp_strike_price, sizeof(tmp_strike_price));
  if (raw_strike_price != 0) {
    _this->_internal_set_strike_price(from._internal_strike_price());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_time_to_expiration = from._internal_time_to_expiration();
  ::uint64_t raw_time_to_expiration;
  memcpy(&raw_time_to_expiration, &tmp_time_to_expiration, sizeof(tmp_time_to_expiration));
  if (raw_time_to_expiration != 0) {
    _this->_internal_set_time_to_expiration(from._internal_time_to_expiration());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_risk_free_interest_rate = from._internal_risk_free_interest_rate();
  ::uint64_t raw_risk_free_interest_rate;
  memcpy(&raw_risk_free_interest_rate, &tmp_risk_free_interest_rate, sizeof(tmp_risk_free_interest_rate));
  if (raw_risk_free_interest_rate != 0) {
    _this->_internal_set_risk_free_interest_rate(from._internal_risk_free_interest_rate());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_drift_rate = from._internal_drift_rate();
  ::uint64_t raw_drift_rate;
  memcpy(&raw_drift_rate, &tmp_drift_rate, sizeof(tmp_drift_rate));
  if (raw_drift_rate != 0) {
    _this->_internal_set_drift_rate(from._internal_drift_rate());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_volatility = from._internal_volatility();
  ::uint64_t raw_volatility;
  memcpy(&raw_volatility, &tmp_volatility, sizeof(tmp_volatility));
  if (raw_volatility != 0) {
    _this->_internal_set_volatility(from._internal_volatility());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mean_reversion_parameter = from._internal_mean_reversion_parameter();
  ::uint64_t raw_mean_reversion_parameter;
  memcpy(&raw_mean_reversion_parameter, &tmp_mean_reversion_parameter, sizeof(tmp_mean_reversion_parameter));
  if (raw_mean_reversion_parameter != 0) {
    _this->_internal_set_mean_reversion_parameter(from._internal_mean_reversion_parameter());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jump_intensity = from._internal_jump_intensity();
  ::uint64_t raw_jump_intensity;
  memcpy(&raw_jump_intensity, &tmp_jump_intensity, sizeof(tmp_jump_intensity));
  if (raw_jump_intensity != 0) {
    _this->_internal_set_jump_intensity(from._internal_jump_intensity());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_jump_size_distribution = from._internal_jump_size_distribution();
  ::uint64_t raw_jump_size_distribution;
  memcpy(&raw_jump_size_distribution, &tmp_jump_size_distribution, sizeof(tmp_jump_size_distribution));
  if (raw_jump_size_distribution != 0) {
    _this->_internal_set_jump_size_distribution(from._internal_jump_size_distribution());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VarianceGammaOptionPricingRequest::CopyFrom(const VarianceGammaOptionPricingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:options.VarianceGammaOptionPricingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VarianceGammaOptionPricingRequest::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* VarianceGammaOptionPricingRequest::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void VarianceGammaOptionPricingRequest::InternalSwap(VarianceGammaOptionPricingRequest* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.jump_size_distribution_)
      + sizeof(VarianceGammaOptionPricingRequest::_impl_.jump_size_distribution_)
      - PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingRequest, _impl_.underlying_price_)>(
          reinterpret_cast<char*>(&_impl_.underlying_price_),
          reinterpret_cast<char*>(&other->_impl_.underlying_price_));
}

::google::protobuf::Metadata VarianceGammaOptionPricingRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_options_2eproto_getter, &descriptor_table_options_2eproto_once,
      file_level_metadata_options_2eproto[4]);
}
// ===================================================================

class VarianceGammaOptionPricingResponse::_Internal {
 public:
};

VarianceGammaOptionPricingResponse::VarianceGammaOptionPricingResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:options.VarianceGammaOptionPricingResponse)
}
VarianceGammaOptionPricingResponse::VarianceGammaOptionPricingResponse(
    ::google::protobuf::Arena* arena, const VarianceGammaOptionPricingResponse& from)
    : VarianceGammaOptionPricingResponse(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE VarianceGammaOptionPricingResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void VarianceGammaOptionPricingResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.option_price_ = {};
}
VarianceGammaOptionPricingResponse::~VarianceGammaOptionPricingResponse() {
  // @@protoc_insertion_point(destructor:options.VarianceGammaOptionPricingResponse)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VarianceGammaOptionPricingResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void VarianceGammaOptionPricingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:options.VarianceGammaOptionPricingResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.option_price_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VarianceGammaOptionPricingResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> VarianceGammaOptionPricingResponse::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VarianceGammaOptionPricingResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double option_price = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingResponse, _impl_.option_price_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double option_price = 1;
    {PROTOBUF_FIELD_OFFSET(VarianceGammaOptionPricingResponse, _impl_.option_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VarianceGammaOptionPricingResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:options.VarianceGammaOptionPricingResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double option_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_option_price = this->_internal_option_price();
  ::uint64_t raw_option_price;
  memcpy(&raw_option_price, &tmp_option_price, sizeof(tmp_option_price));
  if (raw_option_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_option_price(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:options.VarianceGammaOptionPricingResponse)
  return target;
}

::size_t VarianceGammaOptionPricingResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:options.VarianceGammaOptionPricingResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double option_price = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_option_price = this->_internal_option_price();
  ::uint64_t raw_option_price;
  memcpy(&raw_option_price, &tmp_option_price, sizeof(tmp_option_price));
  if (raw_option_price != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VarianceGammaOptionPricingResponse::_class_data_ = {
    VarianceGammaOptionPricingResponse::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* VarianceGammaOptionPricingResponse::GetClassData() const {
  return &_class_data_;
}

void VarianceGammaOptionPricingResponse::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VarianceGammaOptionPricingResponse*>(&to_msg);
  auto& from = static_cast<const VarianceGammaOptionPricingResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:options.VarianceGammaOptionPricingResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_option_price = from._internal_option_price();
  ::uint64_t raw_option_price;
  memcpy(&raw_option_price, &tmp_option_price, sizeof(tmp_option_price));
  if (raw_option_price != 0) {
    _this->_internal_set_option_price(from._internal_option_price());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VarianceGammaOptionPricingResponse::CopyFrom(const VarianceGammaOptionPricingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:options.VarianceGammaOptionPricingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VarianceGammaOptionPricingResponse::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* VarianceGammaOptionPricingResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void VarianceGammaOptionPricingResponse::InternalSwap(VarianceGammaOptionPricingResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.option_price_, other->_impl_.option_price_);
}

::google::protobuf::Metadata VarianceGammaOptionPricingResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_options_2eproto_getter, &descriptor_table_options_2eproto_once,
      file_level_metadata_options_2eproto[5]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace options
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
